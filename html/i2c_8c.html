<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AV_UART_Lab6: src/Source Files/i2c.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AV_UART_Lab6<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Leuart drivers to transmit data over a bluetooth module</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('i2c_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">i2c.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This module configures and implements state machine logic for i2c operation.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;i2c.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad392da40fbc730b1cb2562da0b0a4dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#ad392da40fbc730b1cb2562da0b0a4dcb">i2c_bus_reset</a> (I2C_TypeDef *i2c)</td></tr>
<tr class="memdesc:ad392da40fbc730b1cb2562da0b0a4dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the i2c bus.  <a href="i2c_8c.html#ad392da40fbc730b1cb2562da0b0a4dcb">More...</a><br /></td></tr>
<tr class="separator:ad392da40fbc730b1cb2562da0b0a4dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6164e0cdb560e33c9b0ca60e261abf06"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a6164e0cdb560e33c9b0ca60e261abf06">Ack_Func</a> (<a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *i2c_sm)</td></tr>
<tr class="memdesc:a6164e0cdb560e33c9b0ca60e261abf06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This state machine function services ACK interrupts.  <a href="i2c_8c.html#a6164e0cdb560e33c9b0ca60e261abf06">More...</a><br /></td></tr>
<tr class="separator:a6164e0cdb560e33c9b0ca60e261abf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeecb83c861128b40e46260fbcb930f3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#aaeecb83c861128b40e46260fbcb930f3">Rxdatav_Func</a> (<a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *i2c_sm)</td></tr>
<tr class="memdesc:aaeecb83c861128b40e46260fbcb930f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This state machine function services RXDATAV interrupts.  <a href="i2c_8c.html#aaeecb83c861128b40e46260fbcb930f3">More...</a><br /></td></tr>
<tr class="separator:aaeecb83c861128b40e46260fbcb930f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87095bc42dc2c4cd74600b11702d84b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#ae87095bc42dc2c4cd74600b11702d84b">Stop_Func</a> (<a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *i2c_sm)</td></tr>
<tr class="memdesc:ae87095bc42dc2c4cd74600b11702d84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This state machine function services MSTOP interrupts.  <a href="i2c_8c.html#ae87095bc42dc2c4cd74600b11702d84b">More...</a><br /></td></tr>
<tr class="separator:ae87095bc42dc2c4cd74600b11702d84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a20297b8134a79fabec00ff02cd01e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a6a20297b8134a79fabec00ff02cd01e5">i2c_start</a> (I2C_TypeDef *i2c, uint32_t device_address, OPERATION_MODE mode, uint32_t *data, uint32_t bytes_expected, uint32_t desired_register_address, uint32_t app_cb)</td></tr>
<tr class="memdesc:a6a20297b8134a79fabec00ff02cd01e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begins i2c read/write operations.  <a href="i2c_8c.html#a6a20297b8134a79fabec00ff02cd01e5">More...</a><br /></td></tr>
<tr class="separator:a6a20297b8134a79fabec00ff02cd01e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd501191443ae27fa7ab059461676249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#afd501191443ae27fa7ab059461676249">i2c_open</a> (I2C_TypeDef *i2c, <a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a> *i2c_setup)</td></tr>
<tr class="memdesc:afd501191443ae27fa7ab059461676249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes i2c peripherals.  <a href="i2c_8c.html#afd501191443ae27fa7ab059461676249">More...</a><br /></td></tr>
<tr class="separator:afd501191443ae27fa7ab059461676249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4a964fff4a61065fa343d328ea3df6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a3a4a964fff4a61065fa343d328ea3df6">i2c_available</a> (I2C_TypeDef *i2c)</td></tr>
<tr class="memdesc:a3a4a964fff4a61065fa343d328ea3df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the i2c peripheral availability state.  <a href="i2c_8c.html#a3a4a964fff4a61065fa343d328ea3df6">More...</a><br /></td></tr>
<tr class="separator:a3a4a964fff4a61065fa343d328ea3df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a8e817e99d2a59e5f48e4ff0c79e7eef5">I2C0_IRQHandler</a> (void)</td></tr>
<tr class="memdesc:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for the I2C0 peripheral.  <a href="i2c_8c.html#a8e817e99d2a59e5f48e4ff0c79e7eef5">More...</a><br /></td></tr>
<tr class="separator:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45e5675f6f4e6e1dee2273baf245219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#ac45e5675f6f4e6e1dee2273baf245219">I2C1_IRQHandler</a> (void)</td></tr>
<tr class="memdesc:ac45e5675f6f4e6e1dee2273baf245219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt handler for the I2C1 peripheral.  <a href="i2c_8c.html#ac45e5675f6f4e6e1dee2273baf245219">More...</a><br /></td></tr>
<tr class="separator:ac45e5675f6f4e6e1dee2273baf245219"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a72191069cd54a8d558630741362c6354"><td class="memItemLeft" align="right" valign="top"><a id="a72191069cd54a8d558630741362c6354" name="a72191069cd54a8d558630741362c6354"></a>
static <a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c0_state</b></td></tr>
<tr class="separator:a72191069cd54a8d558630741362c6354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215eaaaad8bb63b3658c77f6a0a7f6f9"><td class="memItemLeft" align="right" valign="top"><a id="a215eaaaad8bb63b3658c77f6a0a7f6f9" name="a215eaaaad8bb63b3658c77f6a0a7f6f9"></a>
static <a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c1_state</b></td></tr>
<tr class="separator:a215eaaaad8bb63b3658c77f6a0a7f6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This module configures and implements state machine logic for i2c operation. </p>
<p ><a class="el" href="gpio_8c.html" title="Sets up the LED output pins for use.">gpio.c</a> </p><dl class="section author"><dt>Author</dt><dd>Adam Vitti </dd></dl>
<dl class="section date"><dt>Date</dt><dd>10/16/21 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a6164e0cdb560e33c9b0ca60e261abf06" name="a6164e0cdb560e33c9b0ca60e261abf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6164e0cdb560e33c9b0ca60e261abf06">&#9670;&nbsp;</a></span>Ack_Func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Ack_Func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *&#160;</td>
          <td class="paramname"><em>i2c_sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This state machine function services ACK interrupts. </p>
<p >Once the mighty gecko receives an ACK from the i2c peripheral, it will execute 1 of 3 operations depending on its state machine current state. If the current state is "initialize_device_data" it will then execute the logic to specify the register desired for data and determine whether this is a "read" or "write" operation and change the state accordingly. If the current state is "write_desired_register" we have already executed the logic specified before, and will then execute the logic in order to read from the device If the current state is "write_data," indicating a "write" operation, the logic will write data to the TXDATA register to be transmitted. If the current state is neither of the previously mentioned states, the function will throw an EFM ASSERT false because we should never have an ACK within the other states. After the completion of each logic specified, the state machine state will be incremented to the next state.</p>
<dl class="section note"><dt>Note</dt><dd>This function is called within the i2c interrupt request handler if an ACK bit is set within the interrupt flag register </dd></dl>

</div>
</div>
<a id="a8e817e99d2a59e5f48e4ff0c79e7eef5" name="a8e817e99d2a59e5f48e4ff0c79e7eef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e817e99d2a59e5f48e4ff0c79e7eef5">&#9670;&nbsp;</a></span>I2C0_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C0_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt handler for the I2C0 peripheral. </p>
<p >This function handles all interrupts triggered within the i2c0 peripheral. It will call state machine functions to service the interrupt triggered based on its current state.</p>
<dl class="section note"><dt>Note</dt><dd>This function will respond and handle the ACK, RXDATAV, and MSTOP interrupts </dd></dl>

</div>
</div>
<a id="ac45e5675f6f4e6e1dee2273baf245219" name="ac45e5675f6f4e6e1dee2273baf245219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45e5675f6f4e6e1dee2273baf245219">&#9670;&nbsp;</a></span>I2C1_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C1_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt handler for the I2C1 peripheral. </p>
<p >This function handles all interrupts triggered within the i2c1 peripheral. It will call state machine functions to service the interrupt triggered based on its current state.</p>
<dl class="section note"><dt>Note</dt><dd>This function will respond and handle the ACK, RXDATAV, and MSTOP interrupts </dd></dl>

</div>
</div>
<a id="a3a4a964fff4a61065fa343d328ea3df6" name="a3a4a964fff4a61065fa343d328ea3df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4a964fff4a61065fa343d328ea3df6">&#9670;&nbsp;</a></span>i2c_available()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool i2c_available </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the i2c peripheral availability state. </p>
<p >This function will indicate whether or not the i2c peripheral is currently performing an operation or available for use, indicating all operations have completed.</p>
<dl class="section note"><dt>Note</dt><dd>This function will be used within si1133 config to determine if i2c operations have completed and data is valid and available. </dd></dl>

</div>
</div>
<a id="ad392da40fbc730b1cb2562da0b0a4dcb" name="ad392da40fbc730b1cb2562da0b0a4dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad392da40fbc730b1cb2562da0b0a4dcb">&#9670;&nbsp;</a></span>i2c_bus_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_bus_reset </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the i2c bus. </p>
<p >This function sends an abort command to stop any i2c operation, clears the interrupt flag register (after saving the interrupt state), clears the transmit register, then sends a start and stop command simultaneously in order to reset the entire peripheral. After reset, the interrupt enable register is restored to its previous state.</p>
<dl class="section note"><dt>Note</dt><dd>This function is called once in <a class="el" href="app_8c.html#ab8cdb39575ad0f98ace1c6fbd9c54b83" title="This function initializes/opens all of our peripherals.">app_peripheral_setup()</a> in order to setup i2c in the operation mode specific to this application.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>A pointer/address to the desired i2c peripheral to be reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd501191443ae27fa7ab059461676249" name="afd501191443ae27fa7ab059461676249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd501191443ae27fa7ab059461676249">&#9670;&nbsp;</a></span>i2c_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_open </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a> *&#160;</td>
          <td class="paramname"><em>i2c_setup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes i2c peripherals. </p>
<p >This function initializes either the I2C0 or I2C1 peripheral clocks and sets all necessary values for setup. It then routes the i2c peripheral to the desired sensor/device, and enables interrupts</p>
<dl class="section note"><dt>Note</dt><dd>This function is called once in <a class="el" href="app_8c.html#ab8cdb39575ad0f98ace1c6fbd9c54b83" title="This function initializes/opens all of our peripherals.">app_peripheral_setup()</a> in order to setup i2c in the operation mode specific to this application.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>A pointer/address to the desired i2c peripheral to be initialized</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c_setup</td><td>A struct that contains all the app specific values for initialization:<ol type="1">
<li>Clock low/high ratio</li>
<li>Frequency of operation</li>
<li>Master bit</li>
<li>Reference frequency</li>
<li>Enable bit As well as route locations for the peripheral. </li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a20297b8134a79fabec00ff02cd01e5" name="a6a20297b8134a79fabec00ff02cd01e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a20297b8134a79fabec00ff02cd01e5">&#9670;&nbsp;</a></span>i2c_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_start </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>device_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OPERATION_MODE&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bytes_expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>desired_register_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>app_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Begins i2c read/write operations. </p>
<p >This function will start either the I2C0 or I2C1 peripheral with the specified arguments in the function call.</p>
<dl class="section note"><dt>Note</dt><dd>This function will be used in a sensor/peripheral driver to read or write data to a device by using the function parameters</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>A pointer/address to the desired i2c peripheral to be used in operation</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">device_address</td><td>Address of the slave peripheral to communicate with over i2c</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Operation mode of the i2c peripheral, either "write" or "read"</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A pointer to the data variable that will hold the data read off or written to the slave device</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes_expected</td><td>Number of bytes desired to read off or write to the slave device</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desired_register_address</td><td>Address of the slave register desired to read or write to</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_cb</td><td>Call back function to be serviced after i2c operation completes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaeecb83c861128b40e46260fbcb930f3" name="aaeecb83c861128b40e46260fbcb930f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeecb83c861128b40e46260fbcb930f3">&#9670;&nbsp;</a></span>Rxdatav_Func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Rxdatav_Func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *&#160;</td>
          <td class="paramname"><em>i2c_sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This state machine function services RXDATAV interrupts. </p>
<p >Once the mighty gecko sees receive data available from the i2c peripheral, it will execute logic to read data from the peripherals specified register. The logic will read a single byte from the RXDATAV register and send an ACK to the peripheral if more data is expected for read. The state machine state will not be incremented, keeping the read data operation in a loop until the number of bytes expected are read from the peripheral. At this point the logi will send a NACK and STOP command indicating the read operation is complete, and then increment the state machine state. If the current state is not in the "initialize_device_read" state, the function will throw an EFM ASSERT false because we should never have RXDATAV within the other states.</p>
<dl class="section note"><dt>Note</dt><dd>This function is called within the i2c interrupt request handler if a RXDATAV bit is set within the interrupt flag register </dd></dl>

</div>
</div>
<a id="ae87095bc42dc2c4cd74600b11702d84b" name="ae87095bc42dc2c4cd74600b11702d84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87095bc42dc2c4cd74600b11702d84b">&#9670;&nbsp;</a></span>Stop_Func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Stop_Func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a> *&#160;</td>
          <td class="paramname"><em>i2c_sm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This state machine function services MSTOP interrupts. </p>
<p >This function will verify that a stop condition has been sent along the i2c peripheral. The only way this function is called is when the MSTOP bit within the IF register is set, so the act of entering this function verifies the stop condition. Once it is known that i2c operation is complete, the mighty gecko energy modes will be unblocked and the i2c peripheral will be free to perform other i2c operations. Additionally, at the end of the i2c operation, an event will be scheduled to pass the received data up to application code. The state machine will then be reset to its initial state. If the current state is not in the "receive_data" state, the function will throw an EFM ASSERT false because we should never have an MSTOP within the other states.</p>
<dl class="section note"><dt>Note</dt><dd>This function is called within the i2c interrupt request handler if a MSTOP bit is set within the interrupt flag register </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_c9e40434d11e5548a56e3b283ebc6198.html">Source Files</a></li><li class="navelem"><a class="el" href="i2c_8c.html">i2c.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
